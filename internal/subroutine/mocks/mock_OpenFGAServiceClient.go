// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	openfgav1 "github.com/openfga/api/proto/openfga/v1"
)

// MockOpenFGAServiceClient is an autogenerated mock type for the OpenFGAServiceClient type
type MockOpenFGAServiceClient struct {
	mock.Mock
}

type MockOpenFGAServiceClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockOpenFGAServiceClient) EXPECT() *MockOpenFGAServiceClient_Expecter {
	return &MockOpenFGAServiceClient_Expecter{mock: &_m.Mock}
}

// BatchCheck provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) BatchCheck(ctx context.Context, in *openfgav1.BatchCheckRequest, opts ...grpc.CallOption) (*openfgav1.BatchCheckResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BatchCheck")
	}

	var r0 *openfgav1.BatchCheckResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.BatchCheckRequest, ...grpc.CallOption) (*openfgav1.BatchCheckResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.BatchCheckRequest, ...grpc.CallOption) *openfgav1.BatchCheckResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.BatchCheckResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.BatchCheckRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_BatchCheck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchCheck'
type MockOpenFGAServiceClient_BatchCheck_Call struct {
	*mock.Call
}

// BatchCheck is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.BatchCheckRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) BatchCheck(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_BatchCheck_Call {
	return &MockOpenFGAServiceClient_BatchCheck_Call{Call: _e.mock.On("BatchCheck",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_BatchCheck_Call) Run(run func(ctx context.Context, in *openfgav1.BatchCheckRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_BatchCheck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.BatchCheckRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_BatchCheck_Call) Return(_a0 *openfgav1.BatchCheckResponse, _a1 error) *MockOpenFGAServiceClient_BatchCheck_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_BatchCheck_Call) RunAndReturn(run func(context.Context, *openfgav1.BatchCheckRequest, ...grpc.CallOption) (*openfgav1.BatchCheckResponse, error)) *MockOpenFGAServiceClient_BatchCheck_Call {
	_c.Call.Return(run)
	return _c
}

// Check provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) Check(ctx context.Context, in *openfgav1.CheckRequest, opts ...grpc.CallOption) (*openfgav1.CheckResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Check")
	}

	var r0 *openfgav1.CheckResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.CheckRequest, ...grpc.CallOption) (*openfgav1.CheckResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.CheckRequest, ...grpc.CallOption) *openfgav1.CheckResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.CheckResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.CheckRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_Check_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Check'
type MockOpenFGAServiceClient_Check_Call struct {
	*mock.Call
}

// Check is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.CheckRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) Check(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_Check_Call {
	return &MockOpenFGAServiceClient_Check_Call{Call: _e.mock.On("Check",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_Check_Call) Run(run func(ctx context.Context, in *openfgav1.CheckRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_Check_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.CheckRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_Check_Call) Return(_a0 *openfgav1.CheckResponse, _a1 error) *MockOpenFGAServiceClient_Check_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_Check_Call) RunAndReturn(run func(context.Context, *openfgav1.CheckRequest, ...grpc.CallOption) (*openfgav1.CheckResponse, error)) *MockOpenFGAServiceClient_Check_Call {
	_c.Call.Return(run)
	return _c
}

// CreateStore provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) CreateStore(ctx context.Context, in *openfgav1.CreateStoreRequest, opts ...grpc.CallOption) (*openfgav1.CreateStoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateStore")
	}

	var r0 *openfgav1.CreateStoreResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.CreateStoreRequest, ...grpc.CallOption) (*openfgav1.CreateStoreResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.CreateStoreRequest, ...grpc.CallOption) *openfgav1.CreateStoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.CreateStoreResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.CreateStoreRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_CreateStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateStore'
type MockOpenFGAServiceClient_CreateStore_Call struct {
	*mock.Call
}

// CreateStore is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.CreateStoreRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) CreateStore(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_CreateStore_Call {
	return &MockOpenFGAServiceClient_CreateStore_Call{Call: _e.mock.On("CreateStore",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_CreateStore_Call) Run(run func(ctx context.Context, in *openfgav1.CreateStoreRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_CreateStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.CreateStoreRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_CreateStore_Call) Return(_a0 *openfgav1.CreateStoreResponse, _a1 error) *MockOpenFGAServiceClient_CreateStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_CreateStore_Call) RunAndReturn(run func(context.Context, *openfgav1.CreateStoreRequest, ...grpc.CallOption) (*openfgav1.CreateStoreResponse, error)) *MockOpenFGAServiceClient_CreateStore_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteStore provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) DeleteStore(ctx context.Context, in *openfgav1.DeleteStoreRequest, opts ...grpc.CallOption) (*openfgav1.DeleteStoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStore")
	}

	var r0 *openfgav1.DeleteStoreResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.DeleteStoreRequest, ...grpc.CallOption) (*openfgav1.DeleteStoreResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.DeleteStoreRequest, ...grpc.CallOption) *openfgav1.DeleteStoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.DeleteStoreResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.DeleteStoreRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_DeleteStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteStore'
type MockOpenFGAServiceClient_DeleteStore_Call struct {
	*mock.Call
}

// DeleteStore is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.DeleteStoreRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) DeleteStore(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_DeleteStore_Call {
	return &MockOpenFGAServiceClient_DeleteStore_Call{Call: _e.mock.On("DeleteStore",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_DeleteStore_Call) Run(run func(ctx context.Context, in *openfgav1.DeleteStoreRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_DeleteStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.DeleteStoreRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_DeleteStore_Call) Return(_a0 *openfgav1.DeleteStoreResponse, _a1 error) *MockOpenFGAServiceClient_DeleteStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_DeleteStore_Call) RunAndReturn(run func(context.Context, *openfgav1.DeleteStoreRequest, ...grpc.CallOption) (*openfgav1.DeleteStoreResponse, error)) *MockOpenFGAServiceClient_DeleteStore_Call {
	_c.Call.Return(run)
	return _c
}

// Expand provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) Expand(ctx context.Context, in *openfgav1.ExpandRequest, opts ...grpc.CallOption) (*openfgav1.ExpandResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Expand")
	}

	var r0 *openfgav1.ExpandResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ExpandRequest, ...grpc.CallOption) (*openfgav1.ExpandResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ExpandRequest, ...grpc.CallOption) *openfgav1.ExpandResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ExpandResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ExpandRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_Expand_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Expand'
type MockOpenFGAServiceClient_Expand_Call struct {
	*mock.Call
}

// Expand is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ExpandRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) Expand(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_Expand_Call {
	return &MockOpenFGAServiceClient_Expand_Call{Call: _e.mock.On("Expand",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_Expand_Call) Run(run func(ctx context.Context, in *openfgav1.ExpandRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_Expand_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ExpandRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_Expand_Call) Return(_a0 *openfgav1.ExpandResponse, _a1 error) *MockOpenFGAServiceClient_Expand_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_Expand_Call) RunAndReturn(run func(context.Context, *openfgav1.ExpandRequest, ...grpc.CallOption) (*openfgav1.ExpandResponse, error)) *MockOpenFGAServiceClient_Expand_Call {
	_c.Call.Return(run)
	return _c
}

// GetStore provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) GetStore(ctx context.Context, in *openfgav1.GetStoreRequest, opts ...grpc.CallOption) (*openfgav1.GetStoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStore")
	}

	var r0 *openfgav1.GetStoreResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.GetStoreRequest, ...grpc.CallOption) (*openfgav1.GetStoreResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.GetStoreRequest, ...grpc.CallOption) *openfgav1.GetStoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.GetStoreResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.GetStoreRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_GetStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStore'
type MockOpenFGAServiceClient_GetStore_Call struct {
	*mock.Call
}

// GetStore is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.GetStoreRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) GetStore(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_GetStore_Call {
	return &MockOpenFGAServiceClient_GetStore_Call{Call: _e.mock.On("GetStore",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_GetStore_Call) Run(run func(ctx context.Context, in *openfgav1.GetStoreRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_GetStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.GetStoreRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_GetStore_Call) Return(_a0 *openfgav1.GetStoreResponse, _a1 error) *MockOpenFGAServiceClient_GetStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_GetStore_Call) RunAndReturn(run func(context.Context, *openfgav1.GetStoreRequest, ...grpc.CallOption) (*openfgav1.GetStoreResponse, error)) *MockOpenFGAServiceClient_GetStore_Call {
	_c.Call.Return(run)
	return _c
}

// ListObjects provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) ListObjects(ctx context.Context, in *openfgav1.ListObjectsRequest, opts ...grpc.CallOption) (*openfgav1.ListObjectsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListObjects")
	}

	var r0 *openfgav1.ListObjectsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListObjectsRequest, ...grpc.CallOption) (*openfgav1.ListObjectsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListObjectsRequest, ...grpc.CallOption) *openfgav1.ListObjectsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ListObjectsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ListObjectsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_ListObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListObjects'
type MockOpenFGAServiceClient_ListObjects_Call struct {
	*mock.Call
}

// ListObjects is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ListObjectsRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ListObjects(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ListObjects_Call {
	return &MockOpenFGAServiceClient_ListObjects_Call{Call: _e.mock.On("ListObjects",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ListObjects_Call) Run(run func(ctx context.Context, in *openfgav1.ListObjectsRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ListObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ListObjectsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ListObjects_Call) Return(_a0 *openfgav1.ListObjectsResponse, _a1 error) *MockOpenFGAServiceClient_ListObjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_ListObjects_Call) RunAndReturn(run func(context.Context, *openfgav1.ListObjectsRequest, ...grpc.CallOption) (*openfgav1.ListObjectsResponse, error)) *MockOpenFGAServiceClient_ListObjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListStores provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) ListStores(ctx context.Context, in *openfgav1.ListStoresRequest, opts ...grpc.CallOption) (*openfgav1.ListStoresResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStores")
	}

	var r0 *openfgav1.ListStoresResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListStoresRequest, ...grpc.CallOption) (*openfgav1.ListStoresResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListStoresRequest, ...grpc.CallOption) *openfgav1.ListStoresResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ListStoresResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ListStoresRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_ListStores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListStores'
type MockOpenFGAServiceClient_ListStores_Call struct {
	*mock.Call
}

// ListStores is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ListStoresRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ListStores(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ListStores_Call {
	return &MockOpenFGAServiceClient_ListStores_Call{Call: _e.mock.On("ListStores",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ListStores_Call) Run(run func(ctx context.Context, in *openfgav1.ListStoresRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ListStores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ListStoresRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ListStores_Call) Return(_a0 *openfgav1.ListStoresResponse, _a1 error) *MockOpenFGAServiceClient_ListStores_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_ListStores_Call) RunAndReturn(run func(context.Context, *openfgav1.ListStoresRequest, ...grpc.CallOption) (*openfgav1.ListStoresResponse, error)) *MockOpenFGAServiceClient_ListStores_Call {
	_c.Call.Return(run)
	return _c
}

// ListUsers provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) ListUsers(ctx context.Context, in *openfgav1.ListUsersRequest, opts ...grpc.CallOption) (*openfgav1.ListUsersResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 *openfgav1.ListUsersResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListUsersRequest, ...grpc.CallOption) (*openfgav1.ListUsersResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ListUsersRequest, ...grpc.CallOption) *openfgav1.ListUsersResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ListUsersResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ListUsersRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_ListUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUsers'
type MockOpenFGAServiceClient_ListUsers_Call struct {
	*mock.Call
}

// ListUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ListUsersRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ListUsers(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ListUsers_Call {
	return &MockOpenFGAServiceClient_ListUsers_Call{Call: _e.mock.On("ListUsers",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ListUsers_Call) Run(run func(ctx context.Context, in *openfgav1.ListUsersRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ListUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ListUsersRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ListUsers_Call) Return(_a0 *openfgav1.ListUsersResponse, _a1 error) *MockOpenFGAServiceClient_ListUsers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_ListUsers_Call) RunAndReturn(run func(context.Context, *openfgav1.ListUsersRequest, ...grpc.CallOption) (*openfgav1.ListUsersResponse, error)) *MockOpenFGAServiceClient_ListUsers_Call {
	_c.Call.Return(run)
	return _c
}

// Read provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) Read(ctx context.Context, in *openfgav1.ReadRequest, opts ...grpc.CallOption) (*openfgav1.ReadResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 *openfgav1.ReadResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadRequest, ...grpc.CallOption) (*openfgav1.ReadResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadRequest, ...grpc.CallOption) *openfgav1.ReadResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type MockOpenFGAServiceClient_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) Read(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_Read_Call {
	return &MockOpenFGAServiceClient_Read_Call{Call: _e.mock.On("Read",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_Read_Call) Run(run func(ctx context.Context, in *openfgav1.ReadRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ReadRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_Read_Call) Return(_a0 *openfgav1.ReadResponse, _a1 error) *MockOpenFGAServiceClient_Read_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_Read_Call) RunAndReturn(run func(context.Context, *openfgav1.ReadRequest, ...grpc.CallOption) (*openfgav1.ReadResponse, error)) *MockOpenFGAServiceClient_Read_Call {
	_c.Call.Return(run)
	return _c
}

// ReadAssertions provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) ReadAssertions(ctx context.Context, in *openfgav1.ReadAssertionsRequest, opts ...grpc.CallOption) (*openfgav1.ReadAssertionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReadAssertions")
	}

	var r0 *openfgav1.ReadAssertionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAssertionsRequest, ...grpc.CallOption) (*openfgav1.ReadAssertionsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAssertionsRequest, ...grpc.CallOption) *openfgav1.ReadAssertionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadAssertionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadAssertionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_ReadAssertions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadAssertions'
type MockOpenFGAServiceClient_ReadAssertions_Call struct {
	*mock.Call
}

// ReadAssertions is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadAssertionsRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ReadAssertions(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ReadAssertions_Call {
	return &MockOpenFGAServiceClient_ReadAssertions_Call{Call: _e.mock.On("ReadAssertions",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ReadAssertions_Call) Run(run func(ctx context.Context, in *openfgav1.ReadAssertionsRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ReadAssertions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ReadAssertionsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadAssertions_Call) Return(_a0 *openfgav1.ReadAssertionsResponse, _a1 error) *MockOpenFGAServiceClient_ReadAssertions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadAssertions_Call) RunAndReturn(run func(context.Context, *openfgav1.ReadAssertionsRequest, ...grpc.CallOption) (*openfgav1.ReadAssertionsResponse, error)) *MockOpenFGAServiceClient_ReadAssertions_Call {
	_c.Call.Return(run)
	return _c
}

// ReadAuthorizationModel provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) ReadAuthorizationModel(ctx context.Context, in *openfgav1.ReadAuthorizationModelRequest, opts ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReadAuthorizationModel")
	}

	var r0 *openfgav1.ReadAuthorizationModelResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelRequest, ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelRequest, ...grpc.CallOption) *openfgav1.ReadAuthorizationModelResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadAuthorizationModelResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadAuthorizationModelRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_ReadAuthorizationModel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadAuthorizationModel'
type MockOpenFGAServiceClient_ReadAuthorizationModel_Call struct {
	*mock.Call
}

// ReadAuthorizationModel is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadAuthorizationModelRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ReadAuthorizationModel(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ReadAuthorizationModel_Call {
	return &MockOpenFGAServiceClient_ReadAuthorizationModel_Call{Call: _e.mock.On("ReadAuthorizationModel",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ReadAuthorizationModel_Call) Run(run func(ctx context.Context, in *openfgav1.ReadAuthorizationModelRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ReadAuthorizationModel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ReadAuthorizationModelRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadAuthorizationModel_Call) Return(_a0 *openfgav1.ReadAuthorizationModelResponse, _a1 error) *MockOpenFGAServiceClient_ReadAuthorizationModel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadAuthorizationModel_Call) RunAndReturn(run func(context.Context, *openfgav1.ReadAuthorizationModelRequest, ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelResponse, error)) *MockOpenFGAServiceClient_ReadAuthorizationModel_Call {
	_c.Call.Return(run)
	return _c
}

// ReadAuthorizationModels provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) ReadAuthorizationModels(ctx context.Context, in *openfgav1.ReadAuthorizationModelsRequest, opts ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReadAuthorizationModels")
	}

	var r0 *openfgav1.ReadAuthorizationModelsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelsRequest, ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelsRequest, ...grpc.CallOption) *openfgav1.ReadAuthorizationModelsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadAuthorizationModelsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadAuthorizationModelsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_ReadAuthorizationModels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadAuthorizationModels'
type MockOpenFGAServiceClient_ReadAuthorizationModels_Call struct {
	*mock.Call
}

// ReadAuthorizationModels is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadAuthorizationModelsRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ReadAuthorizationModels(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ReadAuthorizationModels_Call {
	return &MockOpenFGAServiceClient_ReadAuthorizationModels_Call{Call: _e.mock.On("ReadAuthorizationModels",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ReadAuthorizationModels_Call) Run(run func(ctx context.Context, in *openfgav1.ReadAuthorizationModelsRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ReadAuthorizationModels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ReadAuthorizationModelsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadAuthorizationModels_Call) Return(_a0 *openfgav1.ReadAuthorizationModelsResponse, _a1 error) *MockOpenFGAServiceClient_ReadAuthorizationModels_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadAuthorizationModels_Call) RunAndReturn(run func(context.Context, *openfgav1.ReadAuthorizationModelsRequest, ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelsResponse, error)) *MockOpenFGAServiceClient_ReadAuthorizationModels_Call {
	_c.Call.Return(run)
	return _c
}

// ReadChanges provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) ReadChanges(ctx context.Context, in *openfgav1.ReadChangesRequest, opts ...grpc.CallOption) (*openfgav1.ReadChangesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReadChanges")
	}

	var r0 *openfgav1.ReadChangesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadChangesRequest, ...grpc.CallOption) (*openfgav1.ReadChangesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadChangesRequest, ...grpc.CallOption) *openfgav1.ReadChangesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadChangesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadChangesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_ReadChanges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadChanges'
type MockOpenFGAServiceClient_ReadChanges_Call struct {
	*mock.Call
}

// ReadChanges is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadChangesRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ReadChanges(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ReadChanges_Call {
	return &MockOpenFGAServiceClient_ReadChanges_Call{Call: _e.mock.On("ReadChanges",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ReadChanges_Call) Run(run func(ctx context.Context, in *openfgav1.ReadChangesRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ReadChanges_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.ReadChangesRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadChanges_Call) Return(_a0 *openfgav1.ReadChangesResponse, _a1 error) *MockOpenFGAServiceClient_ReadChanges_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadChanges_Call) RunAndReturn(run func(context.Context, *openfgav1.ReadChangesRequest, ...grpc.CallOption) (*openfgav1.ReadChangesResponse, error)) *MockOpenFGAServiceClient_ReadChanges_Call {
	_c.Call.Return(run)
	return _c
}

// StreamedListObjects provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) StreamedListObjects(ctx context.Context, in *openfgav1.StreamedListObjectsRequest, opts ...grpc.CallOption) (openfgav1.OpenFGAService_StreamedListObjectsClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StreamedListObjects")
	}

	var r0 openfgav1.OpenFGAService_StreamedListObjectsClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.StreamedListObjectsRequest, ...grpc.CallOption) (openfgav1.OpenFGAService_StreamedListObjectsClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.StreamedListObjectsRequest, ...grpc.CallOption) openfgav1.OpenFGAService_StreamedListObjectsClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(openfgav1.OpenFGAService_StreamedListObjectsClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.StreamedListObjectsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_StreamedListObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamedListObjects'
type MockOpenFGAServiceClient_StreamedListObjects_Call struct {
	*mock.Call
}

// StreamedListObjects is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.StreamedListObjectsRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) StreamedListObjects(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_StreamedListObjects_Call {
	return &MockOpenFGAServiceClient_StreamedListObjects_Call{Call: _e.mock.On("StreamedListObjects",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_StreamedListObjects_Call) Run(run func(ctx context.Context, in *openfgav1.StreamedListObjectsRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_StreamedListObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.StreamedListObjectsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_StreamedListObjects_Call) Return(_a0 openfgav1.OpenFGAService_StreamedListObjectsClient, _a1 error) *MockOpenFGAServiceClient_StreamedListObjects_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_StreamedListObjects_Call) RunAndReturn(run func(context.Context, *openfgav1.StreamedListObjectsRequest, ...grpc.CallOption) (openfgav1.OpenFGAService_StreamedListObjectsClient, error)) *MockOpenFGAServiceClient_StreamedListObjects_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStore provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) UpdateStore(ctx context.Context, in *openfgav1.UpdateStoreRequest, opts ...grpc.CallOption) (*openfgav1.UpdateStoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStore")
	}

	var r0 *openfgav1.UpdateStoreResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.UpdateStoreRequest, ...grpc.CallOption) (*openfgav1.UpdateStoreResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.UpdateStoreRequest, ...grpc.CallOption) *openfgav1.UpdateStoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.UpdateStoreResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.UpdateStoreRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_UpdateStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStore'
type MockOpenFGAServiceClient_UpdateStore_Call struct {
	*mock.Call
}

// UpdateStore is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.UpdateStoreRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) UpdateStore(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_UpdateStore_Call {
	return &MockOpenFGAServiceClient_UpdateStore_Call{Call: _e.mock.On("UpdateStore",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_UpdateStore_Call) Run(run func(ctx context.Context, in *openfgav1.UpdateStoreRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_UpdateStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.UpdateStoreRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_UpdateStore_Call) Return(_a0 *openfgav1.UpdateStoreResponse, _a1 error) *MockOpenFGAServiceClient_UpdateStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_UpdateStore_Call) RunAndReturn(run func(context.Context, *openfgav1.UpdateStoreRequest, ...grpc.CallOption) (*openfgav1.UpdateStoreResponse, error)) *MockOpenFGAServiceClient_UpdateStore_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) Write(ctx context.Context, in *openfgav1.WriteRequest, opts ...grpc.CallOption) (*openfgav1.WriteResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 *openfgav1.WriteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteRequest, ...grpc.CallOption) (*openfgav1.WriteResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteRequest, ...grpc.CallOption) *openfgav1.WriteResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.WriteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.WriteRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type MockOpenFGAServiceClient_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.WriteRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) Write(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_Write_Call {
	return &MockOpenFGAServiceClient_Write_Call{Call: _e.mock.On("Write",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_Write_Call) Run(run func(ctx context.Context, in *openfgav1.WriteRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.WriteRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_Write_Call) Return(_a0 *openfgav1.WriteResponse, _a1 error) *MockOpenFGAServiceClient_Write_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_Write_Call) RunAndReturn(run func(context.Context, *openfgav1.WriteRequest, ...grpc.CallOption) (*openfgav1.WriteResponse, error)) *MockOpenFGAServiceClient_Write_Call {
	_c.Call.Return(run)
	return _c
}

// WriteAssertions provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) WriteAssertions(ctx context.Context, in *openfgav1.WriteAssertionsRequest, opts ...grpc.CallOption) (*openfgav1.WriteAssertionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WriteAssertions")
	}

	var r0 *openfgav1.WriteAssertionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAssertionsRequest, ...grpc.CallOption) (*openfgav1.WriteAssertionsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAssertionsRequest, ...grpc.CallOption) *openfgav1.WriteAssertionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.WriteAssertionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.WriteAssertionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_WriteAssertions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteAssertions'
type MockOpenFGAServiceClient_WriteAssertions_Call struct {
	*mock.Call
}

// WriteAssertions is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.WriteAssertionsRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) WriteAssertions(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_WriteAssertions_Call {
	return &MockOpenFGAServiceClient_WriteAssertions_Call{Call: _e.mock.On("WriteAssertions",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_WriteAssertions_Call) Run(run func(ctx context.Context, in *openfgav1.WriteAssertionsRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_WriteAssertions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.WriteAssertionsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_WriteAssertions_Call) Return(_a0 *openfgav1.WriteAssertionsResponse, _a1 error) *MockOpenFGAServiceClient_WriteAssertions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_WriteAssertions_Call) RunAndReturn(run func(context.Context, *openfgav1.WriteAssertionsRequest, ...grpc.CallOption) (*openfgav1.WriteAssertionsResponse, error)) *MockOpenFGAServiceClient_WriteAssertions_Call {
	_c.Call.Return(run)
	return _c
}

// WriteAuthorizationModel provides a mock function with given fields: ctx, in, opts
func (_m *MockOpenFGAServiceClient) WriteAuthorizationModel(ctx context.Context, in *openfgav1.WriteAuthorizationModelRequest, opts ...grpc.CallOption) (*openfgav1.WriteAuthorizationModelResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WriteAuthorizationModel")
	}

	var r0 *openfgav1.WriteAuthorizationModelResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAuthorizationModelRequest, ...grpc.CallOption) (*openfgav1.WriteAuthorizationModelResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAuthorizationModelRequest, ...grpc.CallOption) *openfgav1.WriteAuthorizationModelResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.WriteAuthorizationModelResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *openfgav1.WriteAuthorizationModelRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockOpenFGAServiceClient_WriteAuthorizationModel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteAuthorizationModel'
type MockOpenFGAServiceClient_WriteAuthorizationModel_Call struct {
	*mock.Call
}

// WriteAuthorizationModel is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.WriteAuthorizationModelRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) WriteAuthorizationModel(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_WriteAuthorizationModel_Call {
	return &MockOpenFGAServiceClient_WriteAuthorizationModel_Call{Call: _e.mock.On("WriteAuthorizationModel",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_WriteAuthorizationModel_Call) Run(run func(ctx context.Context, in *openfgav1.WriteAuthorizationModelRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_WriteAuthorizationModel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*openfgav1.WriteAuthorizationModelRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_WriteAuthorizationModel_Call) Return(_a0 *openfgav1.WriteAuthorizationModelResponse, _a1 error) *MockOpenFGAServiceClient_WriteAuthorizationModel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockOpenFGAServiceClient_WriteAuthorizationModel_Call) RunAndReturn(run func(context.Context, *openfgav1.WriteAuthorizationModelRequest, ...grpc.CallOption) (*openfgav1.WriteAuthorizationModelResponse, error)) *MockOpenFGAServiceClient_WriteAuthorizationModel_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockOpenFGAServiceClient creates a new instance of MockOpenFGAServiceClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOpenFGAServiceClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockOpenFGAServiceClient {
	mock := &MockOpenFGAServiceClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
