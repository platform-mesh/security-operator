// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/openfga/api/proto/openfga/v1"
	mock "github.com/stretchr/testify/mock"
	"google.golang.org/grpc"
)

// NewMockOpenFGAServiceClient creates a new instance of MockOpenFGAServiceClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOpenFGAServiceClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockOpenFGAServiceClient {
	mock := &MockOpenFGAServiceClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockOpenFGAServiceClient is an autogenerated mock type for the OpenFGAServiceClient type
type MockOpenFGAServiceClient struct {
	mock.Mock
}

type MockOpenFGAServiceClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockOpenFGAServiceClient) EXPECT() *MockOpenFGAServiceClient_Expecter {
	return &MockOpenFGAServiceClient_Expecter{mock: &_m.Mock}
}

// BatchCheck provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) BatchCheck(ctx context.Context, in *openfgav1.BatchCheckRequest, opts ...grpc.CallOption) (*openfgav1.BatchCheckResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for BatchCheck")
	}

	var r0 *openfgav1.BatchCheckResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.BatchCheckRequest, ...grpc.CallOption) (*openfgav1.BatchCheckResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.BatchCheckRequest, ...grpc.CallOption) *openfgav1.BatchCheckResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.BatchCheckResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.BatchCheckRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_BatchCheck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchCheck'
type MockOpenFGAServiceClient_BatchCheck_Call struct {
	*mock.Call
}

// BatchCheck is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.BatchCheckRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) BatchCheck(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_BatchCheck_Call {
	return &MockOpenFGAServiceClient_BatchCheck_Call{Call: _e.mock.On("BatchCheck",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_BatchCheck_Call) Run(run func(ctx context.Context, in *openfgav1.BatchCheckRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_BatchCheck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.BatchCheckRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.BatchCheckRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_BatchCheck_Call) Return(batchCheckResponse *openfgav1.BatchCheckResponse, err error) *MockOpenFGAServiceClient_BatchCheck_Call {
	_c.Call.Return(batchCheckResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_BatchCheck_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.BatchCheckRequest, opts ...grpc.CallOption) (*openfgav1.BatchCheckResponse, error)) *MockOpenFGAServiceClient_BatchCheck_Call {
	_c.Call.Return(run)
	return _c
}

// Check provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) Check(ctx context.Context, in *openfgav1.CheckRequest, opts ...grpc.CallOption) (*openfgav1.CheckResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Check")
	}

	var r0 *openfgav1.CheckResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.CheckRequest, ...grpc.CallOption) (*openfgav1.CheckResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.CheckRequest, ...grpc.CallOption) *openfgav1.CheckResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.CheckResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.CheckRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_Check_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Check'
type MockOpenFGAServiceClient_Check_Call struct {
	*mock.Call
}

// Check is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.CheckRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) Check(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_Check_Call {
	return &MockOpenFGAServiceClient_Check_Call{Call: _e.mock.On("Check",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_Check_Call) Run(run func(ctx context.Context, in *openfgav1.CheckRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_Check_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.CheckRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.CheckRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_Check_Call) Return(checkResponse *openfgav1.CheckResponse, err error) *MockOpenFGAServiceClient_Check_Call {
	_c.Call.Return(checkResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_Check_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.CheckRequest, opts ...grpc.CallOption) (*openfgav1.CheckResponse, error)) *MockOpenFGAServiceClient_Check_Call {
	_c.Call.Return(run)
	return _c
}

// CreateStore provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) CreateStore(ctx context.Context, in *openfgav1.CreateStoreRequest, opts ...grpc.CallOption) (*openfgav1.CreateStoreResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CreateStore")
	}

	var r0 *openfgav1.CreateStoreResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.CreateStoreRequest, ...grpc.CallOption) (*openfgav1.CreateStoreResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.CreateStoreRequest, ...grpc.CallOption) *openfgav1.CreateStoreResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.CreateStoreResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.CreateStoreRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_CreateStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateStore'
type MockOpenFGAServiceClient_CreateStore_Call struct {
	*mock.Call
}

// CreateStore is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.CreateStoreRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) CreateStore(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_CreateStore_Call {
	return &MockOpenFGAServiceClient_CreateStore_Call{Call: _e.mock.On("CreateStore",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_CreateStore_Call) Run(run func(ctx context.Context, in *openfgav1.CreateStoreRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_CreateStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.CreateStoreRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.CreateStoreRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_CreateStore_Call) Return(createStoreResponse *openfgav1.CreateStoreResponse, err error) *MockOpenFGAServiceClient_CreateStore_Call {
	_c.Call.Return(createStoreResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_CreateStore_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.CreateStoreRequest, opts ...grpc.CallOption) (*openfgav1.CreateStoreResponse, error)) *MockOpenFGAServiceClient_CreateStore_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteStore provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) DeleteStore(ctx context.Context, in *openfgav1.DeleteStoreRequest, opts ...grpc.CallOption) (*openfgav1.DeleteStoreResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteStore")
	}

	var r0 *openfgav1.DeleteStoreResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.DeleteStoreRequest, ...grpc.CallOption) (*openfgav1.DeleteStoreResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.DeleteStoreRequest, ...grpc.CallOption) *openfgav1.DeleteStoreResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.DeleteStoreResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.DeleteStoreRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_DeleteStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteStore'
type MockOpenFGAServiceClient_DeleteStore_Call struct {
	*mock.Call
}

// DeleteStore is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.DeleteStoreRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) DeleteStore(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_DeleteStore_Call {
	return &MockOpenFGAServiceClient_DeleteStore_Call{Call: _e.mock.On("DeleteStore",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_DeleteStore_Call) Run(run func(ctx context.Context, in *openfgav1.DeleteStoreRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_DeleteStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.DeleteStoreRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.DeleteStoreRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_DeleteStore_Call) Return(deleteStoreResponse *openfgav1.DeleteStoreResponse, err error) *MockOpenFGAServiceClient_DeleteStore_Call {
	_c.Call.Return(deleteStoreResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_DeleteStore_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.DeleteStoreRequest, opts ...grpc.CallOption) (*openfgav1.DeleteStoreResponse, error)) *MockOpenFGAServiceClient_DeleteStore_Call {
	_c.Call.Return(run)
	return _c
}

// Expand provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) Expand(ctx context.Context, in *openfgav1.ExpandRequest, opts ...grpc.CallOption) (*openfgav1.ExpandResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Expand")
	}

	var r0 *openfgav1.ExpandResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ExpandRequest, ...grpc.CallOption) (*openfgav1.ExpandResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ExpandRequest, ...grpc.CallOption) *openfgav1.ExpandResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ExpandResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.ExpandRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_Expand_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Expand'
type MockOpenFGAServiceClient_Expand_Call struct {
	*mock.Call
}

// Expand is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ExpandRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) Expand(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_Expand_Call {
	return &MockOpenFGAServiceClient_Expand_Call{Call: _e.mock.On("Expand",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_Expand_Call) Run(run func(ctx context.Context, in *openfgav1.ExpandRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_Expand_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.ExpandRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.ExpandRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_Expand_Call) Return(expandResponse *openfgav1.ExpandResponse, err error) *MockOpenFGAServiceClient_Expand_Call {
	_c.Call.Return(expandResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_Expand_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.ExpandRequest, opts ...grpc.CallOption) (*openfgav1.ExpandResponse, error)) *MockOpenFGAServiceClient_Expand_Call {
	_c.Call.Return(run)
	return _c
}

// GetStore provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) GetStore(ctx context.Context, in *openfgav1.GetStoreRequest, opts ...grpc.CallOption) (*openfgav1.GetStoreResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetStore")
	}

	var r0 *openfgav1.GetStoreResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.GetStoreRequest, ...grpc.CallOption) (*openfgav1.GetStoreResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.GetStoreRequest, ...grpc.CallOption) *openfgav1.GetStoreResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.GetStoreResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.GetStoreRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_GetStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStore'
type MockOpenFGAServiceClient_GetStore_Call struct {
	*mock.Call
}

// GetStore is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.GetStoreRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) GetStore(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_GetStore_Call {
	return &MockOpenFGAServiceClient_GetStore_Call{Call: _e.mock.On("GetStore",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_GetStore_Call) Run(run func(ctx context.Context, in *openfgav1.GetStoreRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_GetStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.GetStoreRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.GetStoreRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_GetStore_Call) Return(getStoreResponse *openfgav1.GetStoreResponse, err error) *MockOpenFGAServiceClient_GetStore_Call {
	_c.Call.Return(getStoreResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_GetStore_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.GetStoreRequest, opts ...grpc.CallOption) (*openfgav1.GetStoreResponse, error)) *MockOpenFGAServiceClient_GetStore_Call {
	_c.Call.Return(run)
	return _c
}

// ListObjects provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) ListObjects(ctx context.Context, in *openfgav1.ListObjectsRequest, opts ...grpc.CallOption) (*openfgav1.ListObjectsResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListObjects")
	}

	var r0 *openfgav1.ListObjectsResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ListObjectsRequest, ...grpc.CallOption) (*openfgav1.ListObjectsResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ListObjectsRequest, ...grpc.CallOption) *openfgav1.ListObjectsResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ListObjectsResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.ListObjectsRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_ListObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListObjects'
type MockOpenFGAServiceClient_ListObjects_Call struct {
	*mock.Call
}

// ListObjects is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ListObjectsRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ListObjects(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ListObjects_Call {
	return &MockOpenFGAServiceClient_ListObjects_Call{Call: _e.mock.On("ListObjects",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ListObjects_Call) Run(run func(ctx context.Context, in *openfgav1.ListObjectsRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ListObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.ListObjectsRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.ListObjectsRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ListObjects_Call) Return(listObjectsResponse *openfgav1.ListObjectsResponse, err error) *MockOpenFGAServiceClient_ListObjects_Call {
	_c.Call.Return(listObjectsResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_ListObjects_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.ListObjectsRequest, opts ...grpc.CallOption) (*openfgav1.ListObjectsResponse, error)) *MockOpenFGAServiceClient_ListObjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListStores provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) ListStores(ctx context.Context, in *openfgav1.ListStoresRequest, opts ...grpc.CallOption) (*openfgav1.ListStoresResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListStores")
	}

	var r0 *openfgav1.ListStoresResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ListStoresRequest, ...grpc.CallOption) (*openfgav1.ListStoresResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ListStoresRequest, ...grpc.CallOption) *openfgav1.ListStoresResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ListStoresResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.ListStoresRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_ListStores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListStores'
type MockOpenFGAServiceClient_ListStores_Call struct {
	*mock.Call
}

// ListStores is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ListStoresRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ListStores(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ListStores_Call {
	return &MockOpenFGAServiceClient_ListStores_Call{Call: _e.mock.On("ListStores",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ListStores_Call) Run(run func(ctx context.Context, in *openfgav1.ListStoresRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ListStores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.ListStoresRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.ListStoresRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ListStores_Call) Return(listStoresResponse *openfgav1.ListStoresResponse, err error) *MockOpenFGAServiceClient_ListStores_Call {
	_c.Call.Return(listStoresResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_ListStores_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.ListStoresRequest, opts ...grpc.CallOption) (*openfgav1.ListStoresResponse, error)) *MockOpenFGAServiceClient_ListStores_Call {
	_c.Call.Return(run)
	return _c
}

// ListUsers provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) ListUsers(ctx context.Context, in *openfgav1.ListUsersRequest, opts ...grpc.CallOption) (*openfgav1.ListUsersResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 *openfgav1.ListUsersResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ListUsersRequest, ...grpc.CallOption) (*openfgav1.ListUsersResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ListUsersRequest, ...grpc.CallOption) *openfgav1.ListUsersResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ListUsersResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.ListUsersRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_ListUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUsers'
type MockOpenFGAServiceClient_ListUsers_Call struct {
	*mock.Call
}

// ListUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ListUsersRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ListUsers(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ListUsers_Call {
	return &MockOpenFGAServiceClient_ListUsers_Call{Call: _e.mock.On("ListUsers",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ListUsers_Call) Run(run func(ctx context.Context, in *openfgav1.ListUsersRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ListUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.ListUsersRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.ListUsersRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ListUsers_Call) Return(listUsersResponse *openfgav1.ListUsersResponse, err error) *MockOpenFGAServiceClient_ListUsers_Call {
	_c.Call.Return(listUsersResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_ListUsers_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.ListUsersRequest, opts ...grpc.CallOption) (*openfgav1.ListUsersResponse, error)) *MockOpenFGAServiceClient_ListUsers_Call {
	_c.Call.Return(run)
	return _c
}

// Read provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) Read(ctx context.Context, in *openfgav1.ReadRequest, opts ...grpc.CallOption) (*openfgav1.ReadResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 *openfgav1.ReadResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadRequest, ...grpc.CallOption) (*openfgav1.ReadResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadRequest, ...grpc.CallOption) *openfgav1.ReadResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type MockOpenFGAServiceClient_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) Read(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_Read_Call {
	return &MockOpenFGAServiceClient_Read_Call{Call: _e.mock.On("Read",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_Read_Call) Run(run func(ctx context.Context, in *openfgav1.ReadRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.ReadRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.ReadRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_Read_Call) Return(readResponse *openfgav1.ReadResponse, err error) *MockOpenFGAServiceClient_Read_Call {
	_c.Call.Return(readResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_Read_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.ReadRequest, opts ...grpc.CallOption) (*openfgav1.ReadResponse, error)) *MockOpenFGAServiceClient_Read_Call {
	_c.Call.Return(run)
	return _c
}

// ReadAssertions provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) ReadAssertions(ctx context.Context, in *openfgav1.ReadAssertionsRequest, opts ...grpc.CallOption) (*openfgav1.ReadAssertionsResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ReadAssertions")
	}

	var r0 *openfgav1.ReadAssertionsResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAssertionsRequest, ...grpc.CallOption) (*openfgav1.ReadAssertionsResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAssertionsRequest, ...grpc.CallOption) *openfgav1.ReadAssertionsResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadAssertionsResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadAssertionsRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_ReadAssertions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadAssertions'
type MockOpenFGAServiceClient_ReadAssertions_Call struct {
	*mock.Call
}

// ReadAssertions is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadAssertionsRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ReadAssertions(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ReadAssertions_Call {
	return &MockOpenFGAServiceClient_ReadAssertions_Call{Call: _e.mock.On("ReadAssertions",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ReadAssertions_Call) Run(run func(ctx context.Context, in *openfgav1.ReadAssertionsRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ReadAssertions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.ReadAssertionsRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.ReadAssertionsRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadAssertions_Call) Return(readAssertionsResponse *openfgav1.ReadAssertionsResponse, err error) *MockOpenFGAServiceClient_ReadAssertions_Call {
	_c.Call.Return(readAssertionsResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadAssertions_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.ReadAssertionsRequest, opts ...grpc.CallOption) (*openfgav1.ReadAssertionsResponse, error)) *MockOpenFGAServiceClient_ReadAssertions_Call {
	_c.Call.Return(run)
	return _c
}

// ReadAuthorizationModel provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) ReadAuthorizationModel(ctx context.Context, in *openfgav1.ReadAuthorizationModelRequest, opts ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ReadAuthorizationModel")
	}

	var r0 *openfgav1.ReadAuthorizationModelResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelRequest, ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelRequest, ...grpc.CallOption) *openfgav1.ReadAuthorizationModelResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadAuthorizationModelResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadAuthorizationModelRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_ReadAuthorizationModel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadAuthorizationModel'
type MockOpenFGAServiceClient_ReadAuthorizationModel_Call struct {
	*mock.Call
}

// ReadAuthorizationModel is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadAuthorizationModelRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ReadAuthorizationModel(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ReadAuthorizationModel_Call {
	return &MockOpenFGAServiceClient_ReadAuthorizationModel_Call{Call: _e.mock.On("ReadAuthorizationModel",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ReadAuthorizationModel_Call) Run(run func(ctx context.Context, in *openfgav1.ReadAuthorizationModelRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ReadAuthorizationModel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.ReadAuthorizationModelRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.ReadAuthorizationModelRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadAuthorizationModel_Call) Return(readAuthorizationModelResponse *openfgav1.ReadAuthorizationModelResponse, err error) *MockOpenFGAServiceClient_ReadAuthorizationModel_Call {
	_c.Call.Return(readAuthorizationModelResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadAuthorizationModel_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.ReadAuthorizationModelRequest, opts ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelResponse, error)) *MockOpenFGAServiceClient_ReadAuthorizationModel_Call {
	_c.Call.Return(run)
	return _c
}

// ReadAuthorizationModels provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) ReadAuthorizationModels(ctx context.Context, in *openfgav1.ReadAuthorizationModelsRequest, opts ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelsResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ReadAuthorizationModels")
	}

	var r0 *openfgav1.ReadAuthorizationModelsResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelsRequest, ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelsResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadAuthorizationModelsRequest, ...grpc.CallOption) *openfgav1.ReadAuthorizationModelsResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadAuthorizationModelsResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadAuthorizationModelsRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_ReadAuthorizationModels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadAuthorizationModels'
type MockOpenFGAServiceClient_ReadAuthorizationModels_Call struct {
	*mock.Call
}

// ReadAuthorizationModels is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadAuthorizationModelsRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ReadAuthorizationModels(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ReadAuthorizationModels_Call {
	return &MockOpenFGAServiceClient_ReadAuthorizationModels_Call{Call: _e.mock.On("ReadAuthorizationModels",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ReadAuthorizationModels_Call) Run(run func(ctx context.Context, in *openfgav1.ReadAuthorizationModelsRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ReadAuthorizationModels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.ReadAuthorizationModelsRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.ReadAuthorizationModelsRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadAuthorizationModels_Call) Return(readAuthorizationModelsResponse *openfgav1.ReadAuthorizationModelsResponse, err error) *MockOpenFGAServiceClient_ReadAuthorizationModels_Call {
	_c.Call.Return(readAuthorizationModelsResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadAuthorizationModels_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.ReadAuthorizationModelsRequest, opts ...grpc.CallOption) (*openfgav1.ReadAuthorizationModelsResponse, error)) *MockOpenFGAServiceClient_ReadAuthorizationModels_Call {
	_c.Call.Return(run)
	return _c
}

// ReadChanges provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) ReadChanges(ctx context.Context, in *openfgav1.ReadChangesRequest, opts ...grpc.CallOption) (*openfgav1.ReadChangesResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ReadChanges")
	}

	var r0 *openfgav1.ReadChangesResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadChangesRequest, ...grpc.CallOption) (*openfgav1.ReadChangesResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.ReadChangesRequest, ...grpc.CallOption) *openfgav1.ReadChangesResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.ReadChangesResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.ReadChangesRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_ReadChanges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadChanges'
type MockOpenFGAServiceClient_ReadChanges_Call struct {
	*mock.Call
}

// ReadChanges is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.ReadChangesRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) ReadChanges(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_ReadChanges_Call {
	return &MockOpenFGAServiceClient_ReadChanges_Call{Call: _e.mock.On("ReadChanges",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_ReadChanges_Call) Run(run func(ctx context.Context, in *openfgav1.ReadChangesRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_ReadChanges_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.ReadChangesRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.ReadChangesRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadChanges_Call) Return(readChangesResponse *openfgav1.ReadChangesResponse, err error) *MockOpenFGAServiceClient_ReadChanges_Call {
	_c.Call.Return(readChangesResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_ReadChanges_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.ReadChangesRequest, opts ...grpc.CallOption) (*openfgav1.ReadChangesResponse, error)) *MockOpenFGAServiceClient_ReadChanges_Call {
	_c.Call.Return(run)
	return _c
}

// StreamedListObjects provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) StreamedListObjects(ctx context.Context, in *openfgav1.StreamedListObjectsRequest, opts ...grpc.CallOption) (openfgav1.OpenFGAService_StreamedListObjectsClient, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for StreamedListObjects")
	}

	var r0 openfgav1.OpenFGAService_StreamedListObjectsClient
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.StreamedListObjectsRequest, ...grpc.CallOption) (openfgav1.OpenFGAService_StreamedListObjectsClient, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.StreamedListObjectsRequest, ...grpc.CallOption) openfgav1.OpenFGAService_StreamedListObjectsClient); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(openfgav1.OpenFGAService_StreamedListObjectsClient)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.StreamedListObjectsRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_StreamedListObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamedListObjects'
type MockOpenFGAServiceClient_StreamedListObjects_Call struct {
	*mock.Call
}

// StreamedListObjects is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.StreamedListObjectsRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) StreamedListObjects(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_StreamedListObjects_Call {
	return &MockOpenFGAServiceClient_StreamedListObjects_Call{Call: _e.mock.On("StreamedListObjects",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_StreamedListObjects_Call) Run(run func(ctx context.Context, in *openfgav1.StreamedListObjectsRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_StreamedListObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.StreamedListObjectsRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.StreamedListObjectsRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_StreamedListObjects_Call) Return(openFGAService_StreamedListObjectsClient openfgav1.OpenFGAService_StreamedListObjectsClient, err error) *MockOpenFGAServiceClient_StreamedListObjects_Call {
	_c.Call.Return(openFGAService_StreamedListObjectsClient, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_StreamedListObjects_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.StreamedListObjectsRequest, opts ...grpc.CallOption) (openfgav1.OpenFGAService_StreamedListObjectsClient, error)) *MockOpenFGAServiceClient_StreamedListObjects_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStore provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) UpdateStore(ctx context.Context, in *openfgav1.UpdateStoreRequest, opts ...grpc.CallOption) (*openfgav1.UpdateStoreResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for UpdateStore")
	}

	var r0 *openfgav1.UpdateStoreResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.UpdateStoreRequest, ...grpc.CallOption) (*openfgav1.UpdateStoreResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.UpdateStoreRequest, ...grpc.CallOption) *openfgav1.UpdateStoreResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.UpdateStoreResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.UpdateStoreRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_UpdateStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStore'
type MockOpenFGAServiceClient_UpdateStore_Call struct {
	*mock.Call
}

// UpdateStore is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.UpdateStoreRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) UpdateStore(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_UpdateStore_Call {
	return &MockOpenFGAServiceClient_UpdateStore_Call{Call: _e.mock.On("UpdateStore",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_UpdateStore_Call) Run(run func(ctx context.Context, in *openfgav1.UpdateStoreRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_UpdateStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.UpdateStoreRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.UpdateStoreRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_UpdateStore_Call) Return(updateStoreResponse *openfgav1.UpdateStoreResponse, err error) *MockOpenFGAServiceClient_UpdateStore_Call {
	_c.Call.Return(updateStoreResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_UpdateStore_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.UpdateStoreRequest, opts ...grpc.CallOption) (*openfgav1.UpdateStoreResponse, error)) *MockOpenFGAServiceClient_UpdateStore_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) Write(ctx context.Context, in *openfgav1.WriteRequest, opts ...grpc.CallOption) (*openfgav1.WriteResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 *openfgav1.WriteResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteRequest, ...grpc.CallOption) (*openfgav1.WriteResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteRequest, ...grpc.CallOption) *openfgav1.WriteResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.WriteResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.WriteRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type MockOpenFGAServiceClient_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.WriteRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) Write(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_Write_Call {
	return &MockOpenFGAServiceClient_Write_Call{Call: _e.mock.On("Write",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_Write_Call) Run(run func(ctx context.Context, in *openfgav1.WriteRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.WriteRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.WriteRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_Write_Call) Return(writeResponse *openfgav1.WriteResponse, err error) *MockOpenFGAServiceClient_Write_Call {
	_c.Call.Return(writeResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_Write_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.WriteRequest, opts ...grpc.CallOption) (*openfgav1.WriteResponse, error)) *MockOpenFGAServiceClient_Write_Call {
	_c.Call.Return(run)
	return _c
}

// WriteAssertions provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) WriteAssertions(ctx context.Context, in *openfgav1.WriteAssertionsRequest, opts ...grpc.CallOption) (*openfgav1.WriteAssertionsResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for WriteAssertions")
	}

	var r0 *openfgav1.WriteAssertionsResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAssertionsRequest, ...grpc.CallOption) (*openfgav1.WriteAssertionsResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAssertionsRequest, ...grpc.CallOption) *openfgav1.WriteAssertionsResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.WriteAssertionsResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.WriteAssertionsRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_WriteAssertions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteAssertions'
type MockOpenFGAServiceClient_WriteAssertions_Call struct {
	*mock.Call
}

// WriteAssertions is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.WriteAssertionsRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) WriteAssertions(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_WriteAssertions_Call {
	return &MockOpenFGAServiceClient_WriteAssertions_Call{Call: _e.mock.On("WriteAssertions",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_WriteAssertions_Call) Run(run func(ctx context.Context, in *openfgav1.WriteAssertionsRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_WriteAssertions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.WriteAssertionsRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.WriteAssertionsRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_WriteAssertions_Call) Return(writeAssertionsResponse *openfgav1.WriteAssertionsResponse, err error) *MockOpenFGAServiceClient_WriteAssertions_Call {
	_c.Call.Return(writeAssertionsResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_WriteAssertions_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.WriteAssertionsRequest, opts ...grpc.CallOption) (*openfgav1.WriteAssertionsResponse, error)) *MockOpenFGAServiceClient_WriteAssertions_Call {
	_c.Call.Return(run)
	return _c
}

// WriteAuthorizationModel provides a mock function for the type MockOpenFGAServiceClient
func (_mock *MockOpenFGAServiceClient) WriteAuthorizationModel(ctx context.Context, in *openfgav1.WriteAuthorizationModelRequest, opts ...grpc.CallOption) (*openfgav1.WriteAuthorizationModelResponse, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, in, opts)
	} else {
		tmpRet = _mock.Called(ctx, in)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for WriteAuthorizationModel")
	}

	var r0 *openfgav1.WriteAuthorizationModelResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAuthorizationModelRequest, ...grpc.CallOption) (*openfgav1.WriteAuthorizationModelResponse, error)); ok {
		return returnFunc(ctx, in, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *openfgav1.WriteAuthorizationModelRequest, ...grpc.CallOption) *openfgav1.WriteAuthorizationModelResponse); ok {
		r0 = returnFunc(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*openfgav1.WriteAuthorizationModelResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *openfgav1.WriteAuthorizationModelRequest, ...grpc.CallOption) error); ok {
		r1 = returnFunc(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOpenFGAServiceClient_WriteAuthorizationModel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteAuthorizationModel'
type MockOpenFGAServiceClient_WriteAuthorizationModel_Call struct {
	*mock.Call
}

// WriteAuthorizationModel is a helper method to define mock.On call
//   - ctx context.Context
//   - in *openfgav1.WriteAuthorizationModelRequest
//   - opts ...grpc.CallOption
func (_e *MockOpenFGAServiceClient_Expecter) WriteAuthorizationModel(ctx interface{}, in interface{}, opts ...interface{}) *MockOpenFGAServiceClient_WriteAuthorizationModel_Call {
	return &MockOpenFGAServiceClient_WriteAuthorizationModel_Call{Call: _e.mock.On("WriteAuthorizationModel",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockOpenFGAServiceClient_WriteAuthorizationModel_Call) Run(run func(ctx context.Context, in *openfgav1.WriteAuthorizationModelRequest, opts ...grpc.CallOption)) *MockOpenFGAServiceClient_WriteAuthorizationModel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *openfgav1.WriteAuthorizationModelRequest
		if args[1] != nil {
			arg1 = args[1].(*openfgav1.WriteAuthorizationModelRequest)
		}
		var arg2 []grpc.CallOption
		var variadicArgs []grpc.CallOption
		if len(args) > 2 {
			variadicArgs = args[2].([]grpc.CallOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOpenFGAServiceClient_WriteAuthorizationModel_Call) Return(writeAuthorizationModelResponse *openfgav1.WriteAuthorizationModelResponse, err error) *MockOpenFGAServiceClient_WriteAuthorizationModel_Call {
	_c.Call.Return(writeAuthorizationModelResponse, err)
	return _c
}

func (_c *MockOpenFGAServiceClient_WriteAuthorizationModel_Call) RunAndReturn(run func(ctx context.Context, in *openfgav1.WriteAuthorizationModelRequest, opts ...grpc.CallOption) (*openfgav1.WriteAuthorizationModelResponse, error)) *MockOpenFGAServiceClient_WriteAuthorizationModel_Call {
	_c.Call.Return(run)
	return _c
}
